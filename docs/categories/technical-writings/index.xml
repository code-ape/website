<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technical Writings on Ferris Ellis</title>
    <link>https://www.ferrisellis.com/categories/technical-writings/</link>
    <description>Recent content in Technical Writings on Ferris Ellis</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright Ferris Ellis 2017-2021. All rights reserved.</copyright>
    <lastBuildDate>Fri, 02 Feb 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://www.ferrisellis.com/categories/technical-writings/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Lifecycle Versioning (v01, alpha)</title>
      <link>https://www.ferrisellis.com/content/lifecycle_versioning_v1_alpha/</link>
      <pubDate>Fri, 02 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://www.ferrisellis.com/content/lifecycle_versioning_v1_alpha/</guid>
      <description>A descriptoin of what Lifecycle Versioning is, its value as a software development practice, and how to implement it. Currently in alpha form of version 1, feedback welcome.</description>
    </item>
    
    <item>
      <title>eBPF, part 2: Syscall and Map Types</title>
      <link>https://www.ferrisellis.com/content/ebpf_syscall_and_maps/</link>
      <pubDate>Thu, 11 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.ferrisellis.com/content/ebpf_syscall_and_maps/</guid>
      <description>Due to the its fast adoption, using eBPF is different for each system it has been integrated with.
However, the common denominator for all uses is the syscall for eBPF.
This syscall, the &lt;code&gt;bpf&lt;/code&gt; syscall in Linux, allows eBPF programs to be loaded into the kernel and eBPF-maps to be created and manipulated.
As the second installment in the eBPF series, this article works through all the commands of the syscall plus the different eBPF-map types, since they are controlled through the syscall.</description>
    </item>
    
    <item>
      <title>eBPF, part 1: Past, Present, and Future</title>
      <link>https://www.ferrisellis.com/content/ebpf_past_present_future/</link>
      <pubDate>Fri, 28 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.ferrisellis.com/content/ebpf_past_present_future/</guid>
      <description>The Extended Berkeley Packet Filter, or eBPF, has rapidly been adopted into a number of Linux kernel systems since its introduction into the Linux kernel in late 2014.
Understanding eBPF, however, can be difficult as many try to explain it via a use of eBPF as opposed to its design.
Indeed eBPF&amp;rsquo;s name indicates that it is for packet filtering even though it now has uses which have nothing to do with networking.
This article will walk through eBPF&amp;rsquo;s past, present, and future to offer context on how eBPF came to be what it is and what it is likely to become as development on it continues.</description>
    </item>
    
    <item>
      <title>Math with distances in Rust: safety and correctness across units</title>
      <link>https://www.ferrisellis.com/content/rust-implementing-units-for-types/</link>
      <pubDate>Wed, 08 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.ferrisellis.com/content/rust-implementing-units-for-types/</guid>
      <description>Computers weren&amp;rsquo;t designed to have outside concepts, such as units of length, expressed in their function.
Because of this Rust, being a systems language, also has no concept of it.
But just because the computer runtime has no concept of length or units of length doesn&amp;rsquo;t mean we can&amp;rsquo;t teach them to the compiler.
In this article I&amp;rsquo;ll walk through using a generic struct to represent the concept of a length, extend that length to allow any units, and show how to create a system to cleanly and safely do arithmetic with lengths.</description>
    </item>
    
  </channel>
</rss>
