<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FerrisEllis.com</title>
    <link>https://ferrisellis.com/</link>
    <description>Recent content on FerrisEllis.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 11 May 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ferrisellis.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>eBPF, part 2: Syscall and Map Types</title>
      <link>https://ferrisellis.com/posts/ebpf_syscall_and_maps/</link>
      <pubDate>Thu, 11 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ferrisellis.com/posts/ebpf_syscall_and_maps/</guid>
      <description>eBPF, part 2 This article is the second in a series on eBPF. It builds upon the previous article, &amp;ldquo;eBPF, part 1: Past, Present, and Future&amp;rdquo;, by diving into the core of using eBPF: the Linux bpf syscall. In doing so this article hopes to offer a completely fleshed out depiction of the core machinery one must use for utilizing eBPF.
This article also references future articles that will be written for this series.</description>
    </item>
    
    <item>
      <title>eBPF, part 1: Past, Present, and Future</title>
      <link>https://ferrisellis.com/posts/ebpf_past_present_future/</link>
      <pubDate>Fri, 28 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ferrisellis.com/posts/ebpf_past_present_future/</guid>
      <description>eBPF, part 1 This article is the first in a series on eBPF. Each will build on the prior ones and progress from concepts and context towards examples and implementations. This first article will explore eBPF&amp;rsquo;s history, current state, and future trajectory. In doing so I hope to make the current state and function of eBPF more coherent. As with many software projects, eBPF can appear odd and spastic without the context of the history which shaped it.</description>
    </item>
    
    <item>
      <title>Math with distances in Rust: safety and correctness across units</title>
      <link>https://ferrisellis.com/posts/rust-implementing-units-for-types/</link>
      <pubDate>Wed, 08 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ferrisellis.com/posts/rust-implementing-units-for-types/</guid>
      <description>Recently Jasper Schulz wrote an excellent short article titled Communicating Intent. In it he walks through using the newtype-pattern in combination with the From and Into traits for the purpose of allowing the compiler to do all datatype checking and transformation.
The reason things like this are useful is, as shown by Schulz in the article, you can write code which allows type conversions without knowing what your converting from.</description>
    </item>
    
  </channel>
</rss>