<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FerrisEllis.com</title>
    <link>https://ferrisellis.com/</link>
    <description>Recent content on FerrisEllis.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 02 Feb 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ferrisellis.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Lifecycle Versioning (v01, alpha)</title>
      <link>https://ferrisellis.com/posts/lifecycle_versioning_v1_alpha/</link>
      <pubDate>Fri, 02 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://ferrisellis.com/posts/lifecycle_versioning_v1_alpha/</guid>
      <description>The following document is versioned as alpha v1 by it&amp;rsquo;s own definition of such terms. If you are interested in contributing please either submit an issue to the repository for this blog or email me as detailed on the contact section of the about page.
Introduction In the world of software projects, code lives a lifecycle. It is developed, released, packaged, used, and finally decommissioned1; often to be replaced by a successor from the same project.</description>
    </item>
    
    <item>
      <title>Strength in Numbers: Unums and the Quest for Reliable Arithmatic</title>
      <link>https://ferrisellis.com/talks/unums_strange_loop_2017/</link>
      <pubDate>Thu, 28 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ferrisellis.com/talks/unums_strange_loop_2017/</guid>
      <description>A talk by Ferris Ellis at Strange Loop 2017.
Abstract In the land of computer arithmetic, a tyrant has ruled since its very beginning: the floating point number. Under its rule we have all endured countless hardships and cruelties. To this very day the floating point number still denies 0.1 + 0.2 == 0.3 and returns insidious infinities to software developers everywhere. But a new hero has entered fray: the universal number (unum).</description>
    </item>
    
    <item>
      <title>Remote Project Lead: Thoughts and Learnings</title>
      <link>https://ferrisellis.com/posts/project_lead_thoughts/</link>
      <pubDate>Sat, 20 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ferrisellis.com/posts/project_lead_thoughts/</guid>
      <description>This article is written in present tense and first person to provide a more engaging narrative to the reader. However, all statements and claims are made with the time reference to when this was published. Thus &amp;ldquo;today&amp;rdquo; is May 16, 2017.
Special thanks to my colleague Gary Berger for providing feedback on this article.
Intro Project management, leadership, working remotely, team organization, and client relationship management are all topics which have been written about, at length.</description>
    </item>
    
    <item>
      <title>eBPF, part 2: Syscall and Map Types</title>
      <link>https://ferrisellis.com/posts/ebpf_syscall_and_maps/</link>
      <pubDate>Thu, 11 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ferrisellis.com/posts/ebpf_syscall_and_maps/</guid>
      <description>eBPF, part 2 This article is the second in a series on eBPF. It builds upon the previous article, &amp;ldquo;eBPF, part 1: Past, Present, and Future&amp;rdquo;, by diving into the core of using eBPF: the Linux bpf syscall. In doing so this article hopes to offer a completely fleshed out depiction of the core machinery one must use for utilizing eBPF.
This article also references future articles that will be written for this series.</description>
    </item>
    
    <item>
      <title>eBPF, part 1: Past, Present, and Future</title>
      <link>https://ferrisellis.com/posts/ebpf_past_present_future/</link>
      <pubDate>Fri, 28 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ferrisellis.com/posts/ebpf_past_present_future/</guid>
      <description>eBPF, part 1 This article is the first in a series on eBPF. Each will build on the prior ones and progress from concepts and context towards examples and implementations. This first article will explore eBPF&amp;rsquo;s history, current state, and future trajectory. In doing so I hope to make the current state and function of eBPF more coherent. As with many software projects, eBPF can appear odd and spastic without the context of the history which shaped it.</description>
    </item>
    
    <item>
      <title>Math with distances in Rust: safety and correctness across units</title>
      <link>https://ferrisellis.com/posts/rust-implementing-units-for-types/</link>
      <pubDate>Wed, 08 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>https://ferrisellis.com/posts/rust-implementing-units-for-types/</guid>
      <description>Recently Jasper Schulz wrote an excellent short article titled Communicating Intent. In it he walks through using the newtype-pattern in combination with the From and Into traits for the purpose of allowing the compiler to do all datatype checking and transformation.
The reason things like this are useful is, as shown by Schulz in the article, you can write code which allows type conversions without knowing what your converting from.</description>
    </item>
    
  </channel>
</rss>